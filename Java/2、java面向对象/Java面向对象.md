## Java面向对象

### 一、类和对象

1. ##### 面向对象和面向过程的区别？

    - **面向过程** ：**面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展。**

    - **面向对象** ：**面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**。

        面向过程 ：面向过程性能比面向对象高？？

        ```
        这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。
        
        而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。
        ```

2. ##### 构造器Constructor是否可被overide？

    Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。

3. ##### 在Java中定义一个不做事且没有参数的构造方法的作用？

    Java 程序在执行子类的构造方法之前，如果没有用 `super()`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 `super()`来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。

4. ##### 成员变量和局部变量的区别有哪些？

    1. 从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。
    2. 从变量在内存中的存储方式来看:如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
    3. 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
    4. 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

5. ##### 创建一个对象用什么运算符？对象实体与对象引用有何不同？

    new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。

6. ##### 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正常执行吗？为什么？

    主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。

7. ##### 构造方法有哪些特性？

    1. 名字与类名相同。
    2. 没有返回值，但不能用 void 声明构造函数（带void声明的代表是普通方法）。
    3. 生成类的对象时自动执行，无需调用。

8. ##### 在调用子类构造方法之前会先调用父类没有参数的构造方法，目的是什么？

    帮助子类做初始化工作

9. ##### 对象相等与指向他们的引用相等，两者有什么不同？

    对象相等比的是内存中存放的内容是否相等，而引用相等比的是指向的内存地址是否相等。


### 二、面向对象三大特征

1. #### 封装

    封装指把一个对象的状态信息（也就是属性），隐藏在对象的内部，不允许外部直接访问对象的内部信息，但是可以提供一届可以被外界访问的方法来操作属性，就好像我们看不到空调的内部组件（也就是属性），但是可以使用遥控器(方法)来控制空调，如果属性不想被外界访问，就可以不提供方法给外界。但是如果一个类没有提供给外界的方法，name这个类就没什么意义了。

    ```java
    public class Student {
        private int id;//id属性私有化
        private String name;//name属性私有化
    
        //获取id的方法
        public int getId() {
            return id;
        }
    
        //设置id的方法
        public void setId(int id) {
            this.id = id;
        }
    
        //获取name的方法
        public String getName() {
            return name;
        }
    
        //设置name的方法
        public void setName(String name) {
            this.name = name;
        }
    }
    ```

2. #### 继承

    不同的对象，相互之间经常有一定数量的共同点。例如，小茗同学，小红，小刚等都共享学生的特性，同时，每一个对象可能还有不同的特性，比如小明数学好，小红性格好，小刚力气大等。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性的继承父类。通过使用继承，可以快速的创建新的类，提高代码的重用，程序的可维护性，节省大量创建新类的时间，提高开发效率。

    **关于继承需要牢记：**

    1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类无法访问，**只是拥有**。
    2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
    3. 子类可以用自己的方式实现父类的方法（重写/orveride）。

3. #### 多态

    多态，表示一个对象具有多种状态。具体表现为父类的引用指向子类的实例，让对象在编译器和运行期具有不同的状态。

    **多态的特点：**

    - 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
    - 对象类型不可变，引用类型可变；
    - 方法具有多态性，属性不具有多态性；
    - 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
    - 多态不能调用“只在子类存在但在父类不存在”的方法；
    - 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。

### 三、修饰符

1. #### 在一个静态方法中调用一个非静态成员为什么是非法的？

    由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他的非静态变量，也不可以访问非静态变量的成员。

2. #### 静态方法和实例方法有什么不同？

    1. 在外部调用静态方法时，可以试用“类名.方法名”的方式，也可以使用“对象名.方法名的方式”（不推荐，静态方法跟具体的对象已经没有关系），而实例方法只能使用后面的方式。也就是：调用静态方法不需要创建对象
    2. 静态方法在访问本类成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法。实例方法则无此限制。

3. #### 常见的关键字总结，this，static，final，super：

    - **this：用于引用类的当前实例，不能用在静态方法中。此关键字可选。**

    - **static关键字主要有以下四种使用场景：**

        ```
        1、修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名  类名.静态方法名()
        
        2、静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
        
        3、静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
        
        4、静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。
        ```

    - **final关键字主要用在三个地方：变量、方法、类。**

        ```
        1、对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
        
        2、当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
        
        3、使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final
        ```

    - **super关键字用于从子类访问父类的变量和方法。** 

        ```java
        public class Super {
            protected int number;
        
            protected showNumber() {
                System.out.println("number = " + number);
            }
        }
        
        public class Sub extends Super {
            void bar() {
                super.number = 10;
                super.showNumber();
            }
        }
        ```

        - 在构造器中使用 `super（）` 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
        - this、super不能用在static方法中。

### 四、接口类和抽象类

1. #### 接口和抽象类的区别是什么？

    1. 接口的方法默认是public，所有方法在接口中不能有实现（Java 8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。

    2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一样。

    3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。

    4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被抽血所以不能使用private关键字修饰）

    5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

        > 备注：
        >
        > 1. 在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。(详见 issue:https://github.com/Snailclimb/JavaGuide/issues/146。
        > 2. jdk9 的接口被允许定义私有方法 。

        总结一下 jdk7~jdk9 Java 中接口概念的变化：

        1. 在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。
        2. jdk8 的时候接口可以有默认方法和静态方法功能。
        3. Jdk 9 在接口中引入了私有方法和私有静态方法

### 五、其他

1. #### String，StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？

    简单来说：`String`类中使用final关键字修饰字符数组来保存字符串private final char value[]`,所以`String`对象是不可变的。

    > 补充：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 `private final byte[] value`;

    而`StringBuilder`与`StringBuffer`都继承自`AbstractStringBulder`类，在`AbstractStringBuilder`中也是使用字符数组保存字符串`char[] value`，但是没有用final关键字修饰，所以这两种对象都是可变的。

    `StringBuilder`与`StringBuffer`的构造方法都是调用父类构造方法也就是`AbstractStringBuilder`实现的。

    ##### 线程安全性：

    `String`中的对象是不可变，也就可以理解为常量，线程安全。`AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

    ##### 性能：

    每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer`对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

    ##### **三者的总结：**

    1. 操作少量的数据: 适用 `String`
    2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
    3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

2. #### Object类常见方法总结

    (**1)是类层次结构的根类，所有类都直接或者间接的继承自该类。**

    (**2)构造方法：**

    - 有一个无参构造方法。

    **(3)成员方法：**

    ```java
    public final native Class<?> getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。
    
    public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。
    public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。
    
    protected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。
    
    public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。
    
    public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
    
    public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
    
    public final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。
    
    public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。
    
    public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
    
    ```

3. #### ==与equals(重要)

    **==**：作用主要是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象（基本数据类型**==**比较的是值，引用数据类型**==**比较的是内存地址）。

    **equals()：**作用也是判断两个对象是否相等。但它一般有两种使用情况。

    - 情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于使用"=="比较。

    - 情况2：类覆盖了equals()方法。一般，我们覆盖equals()方法来比较两个对象的内容是否相等；若他们的内容相等，则返回true(即认为两个对象相等)。

        **示例：**

        ```java
        public class Test001 {
        	
        	public static void main(String[] args) {
        		
        		String a = new String("ab"); // a为一个引用，
        		String b = new String("ab"); // b为另一个引用，对象的内容一样
        		
        		String aa = "ab";	// 放在常量池中
        		String bb = "ab";	// 从常量中查找
        		if (aa == bb) { // true
        			System.out.println("aa==bb");
        		}
        		if (a == b) {	// false，非同一个对象
        			System.out.println("a==b");
        		}
        		if (a.equals(b)) {	// true
        			System.out.println("a equals b");
        		}
        		if (42 == 42.0) {	// true
        			System.out.println("true");
        		}
        		
        	}
        }
        
        ```

        ##### 说明：

        - String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
        - 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。

4. #### hashCode与equals（重要）

    重写过hashcode和equals么？为什么重写equal时需要重写hashCode方法？

    1. ##### hashCode()介绍

        hashCode作用是获取哈希码，也成为了散列码；实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在JDK的Object。java中，这也意味着Java的任何类都包含有hashCode()函数。

        散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）

    2. ##### 为什么要有 hashCode

5. asd

6. asd

7. asd

8. asd

9. 